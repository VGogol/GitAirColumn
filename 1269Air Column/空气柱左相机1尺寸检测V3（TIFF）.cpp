///////////////////////////////////////////////////////////////////////////////
//  File generated by HDevelop for HALCON/C++ Version 12.0
///////////////////////////////////////////////////////////////////////////////



#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#  if defined(__linux__) && !defined(NO_EXPORT_APP_MAIN)
#    include <X11/Xlib.h>
#  endif
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#  include <stdio.h>
#  include <HALCON/HpThread.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif



using namespace HalconCpp;

// Procedure declarations 
// Chapter: Matching / Shape-Based
// Short Description: Display the results of Shape-Based Matching. 
void dev_display_shape_matching_results (HTuple hv_ModelID, HTuple hv_Color, HTuple hv_Row, 
    HTuple hv_Column, HTuple hv_Angle, HTuple hv_ScaleR, HTuple hv_ScaleC, HTuple hv_Model);

// Procedures 
// Chapter: Matching / Shape-Based
// Short Description: Display the results of Shape-Based Matching. 
void dev_display_shape_matching_results (HTuple hv_ModelID, HTuple hv_Color, HTuple hv_Row, 
    HTuple hv_Column, HTuple hv_Angle, HTuple hv_ScaleR, HTuple hv_ScaleC, HTuple hv_Model)
{

  // Local iconic variables
  HObject  ho_ModelContours, ho_ContoursAffinTrans;

  // Local control variables
  HTuple  hv_NumMatches, hv_Index, hv_Match, hv_HomMat2DIdentity;
  HTuple  hv_HomMat2DScale, hv_HomMat2DRotate, hv_HomMat2DTranslate;

  //This procedure displays the results of Shape-Based Matching.
  //
  hv_NumMatches = hv_Row.TupleLength();
  if (0 != (hv_NumMatches>0))
  {
    if (0 != ((hv_ScaleR.TupleLength())==1))
    {
      TupleGenConst(hv_NumMatches, hv_ScaleR, &hv_ScaleR);
    }
    if (0 != ((hv_ScaleC.TupleLength())==1))
    {
      TupleGenConst(hv_NumMatches, hv_ScaleC, &hv_ScaleC);
    }
    if (0 != ((hv_Model.TupleLength())==0))
    {
      TupleGenConst(hv_NumMatches, 0, &hv_Model);
    }
    else if (0 != ((hv_Model.TupleLength())==1))
    {
      TupleGenConst(hv_NumMatches, hv_Model, &hv_Model);
    }
    {
    HTuple end_val15 = (hv_ModelID.TupleLength())-1;
    HTuple step_val15 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val15, step_val15); hv_Index += step_val15)
    {
      GetShapeModelContours(&ho_ModelContours, HTuple(hv_ModelID[hv_Index]), 1);
      if (HDevWindowStack::IsOpen())
        SetColor(HDevWindowStack::GetActive(),HTuple(hv_Color[hv_Index%(hv_Color.TupleLength())]));
      {
      HTuple end_val18 = hv_NumMatches-1;
      HTuple step_val18 = 1;
      for (hv_Match=0; hv_Match.Continue(end_val18, step_val18); hv_Match += step_val18)
      {
        if (0 != (hv_Index==HTuple(hv_Model[hv_Match])))
        {
          HomMat2dIdentity(&hv_HomMat2DIdentity);
          HomMat2dScale(hv_HomMat2DIdentity, HTuple(hv_ScaleR[hv_Match]), HTuple(hv_ScaleC[hv_Match]), 
              0, 0, &hv_HomMat2DScale);
          HomMat2dRotate(hv_HomMat2DScale, HTuple(hv_Angle[hv_Match]), 0, 0, &hv_HomMat2DRotate);
          HomMat2dTranslate(hv_HomMat2DRotate, HTuple(hv_Row[hv_Match]), HTuple(hv_Column[hv_Match]), 
              &hv_HomMat2DTranslate);
          AffineTransContourXld(ho_ModelContours, &ho_ContoursAffinTrans, hv_HomMat2DTranslate);
          if (HDevWindowStack::IsOpen())
            DispObj(ho_ContoursAffinTrans, HDevWindowStack::GetActive());
        }
      }
      }
    }
    }
  }
  return;
}

#ifndef NO_EXPORT_MAIN
// Main procedure 
void action()
{

  // Local iconic variables
  HObject  ho_Image0, ho_Rectanglerotate, ho_ImageReducedrotate;
  HObject  ho_Regionrotate, ho_Edgesrotate, ho_SelectedContours;
  HObject  ho_ImageRotate, ho_Rectanglediameter1, ho_ImageReduceddiameter1;
  HObject  ho_Regiondiameter1, ho_Edgesdiameter1, ho_SelectedContoursdiameter1;
  HObject  ho_Rectanglediameter2, ho_ImageReduceddiameter2;
  HObject  ho_Regiondiameter2, ho_Edgesdiameter2, ho_SelectedContoursdiameter2;
  HObject  ho_Rectanglelength1, ho_ImageReducedlength1, ho_Regionlength1;
  HObject  ho_Edgeslength1, ho_SelectedContourslength1, ho_Rectanglelength2;
  HObject  ho_ImageReducedlength2, ho_Regionlength2, ho_Edgeslength2;
  HObject  ho_SelectedContourslength2;

  // Local control variables
  HTuple  hv_WindowHandle, hv_ModelID, hv_c, hv_lengthmin;
  HTuple  hv_lengthmax, hv_diameter, hv_ImageFiles, hv_Index;
  HTuple  hv_Row, hv_Column, hv_Angle, hv_Score, hv_Lengthrotate;
  HTuple  hv_Sortedrotate, hv_RowBegin, hv_ColBegin, hv_RowEnd;
  HTuple  hv_ColEnd, hv_Nr, hv_Nc, hv_Dist, hv_Phi, hv_Lengthdiameter1;
  HTuple  hv_Sorteddiameter1, hv_RowBegindiameter1, hv_ColBegindiameter1;
  HTuple  hv_RowEnddiameter1, hv_ColEnddiameter1, hv_Nr1;
  HTuple  hv_Nc1, hv_Dist1, hv_Lengthdiameter2, hv_Sorteddiameter2;
  HTuple  hv_RowBegindiameter2, hv_ColBegindiameter2, hv_RowEnddiameter2;
  HTuple  hv_ColEnddiameter2, hv_Nr2, hv_Nc2, hv_Dist2, hv_Areadiameter1;
  HTuple  hv_Rowdiameter1, hv_Columndiameter1, hv_PointOrderdiameter1;
  HTuple  hv_rowavg1, hv_colavg1, hv_rowavg2, hv_colavg2;
  HTuple  hv_distance1, hv_Sqrtdiameter, hv_Lengthlength1;
  HTuple  hv_Sortedlength1, hv_RowBeginlength1, hv_ColBeginlength1;
  HTuple  hv_RowEndlength1, hv_ColEndlength1, hv_Nrlength1;
  HTuple  hv_Nclength1, hv_Distlength1, hv_Lengthlength2;
  HTuple  hv_Sortedlength2, hv_RowBeginlength2, hv_ColBeginlength2;
  HTuple  hv_RowEndlength2, hv_ColEndlength2, hv_Nrlength2;
  HTuple  hv_Nclength2, hv_Distlength2, hv_DistancelengthMin;
  HTuple  hv_DistancelengthMax;

  if (HDevWindowStack::IsOpen())
    CloseWindow(HDevWindowStack::Pop());
  SetWindowAttr("background_color","black");
  OpenWindow(0,0,650,480,0,"","",&hv_WindowHandle);
  HDevWindowStack::Push(hv_WindowHandle);
  //dev_update_window ('off')
  if (HDevWindowStack::IsOpen())
    SetDraw(HDevWindowStack::GetActive(),"fill");
  ReadShapeModel("./3-19左尺寸模板.shm", &hv_ModelID);
  hv_c = 0;
  hv_lengthmin = HTuple();
  hv_lengthmax = HTuple();
  hv_diameter = HTuple();
  //Image Acquisition 01: Code generated by Image Acquisition 01
  hv_ImageFiles = HTuple();
  //ImageFiles[0] := 'C:/Users/Administrator/Desktop/3-25 1269/2-15.339/1.bmp'
  hv_ImageFiles[0] = "D:/project photo/3-28 1269/右/同一格/1.tiff";
  hv_ImageFiles[1] = "D:/project photo/3-28 1269/右/同一格/2.tiff";
  hv_ImageFiles[2] = "D:/project photo/3-28 1269/右/同一格/3.tiff";
  hv_ImageFiles[3] = "D:/project photo/3-28 1269/右/同一格/4.tiff";
  hv_ImageFiles[4] = "D:/project photo/3-28 1269/右/同一格/5.tiff";
  hv_ImageFiles[5] = "D:/project photo/3-28 1269/右/同一格/6.tiff";
  hv_ImageFiles[6] = "D:/project photo/3-28 1269/右/同一格/7.tiff";
  hv_ImageFiles[7] = "D:/project photo/3-28 1269/右/同一格/8.tiff";
  hv_ImageFiles[8] = "D:/project photo/3-28 1269/右/同一格/9.tiff";
  hv_ImageFiles[9] = "D:/project photo/3-28 1269/右/同一格/10.tiff";
  //ImageFiles[10] := 'D:/project photo/3-28 1269/右/单格/11.tiff'
  //ImageFiles[11] := 'D:/project photo/3-28 1269/右/单格/12.tiff'
  //ImageFiles[12] := 'D:/project photo/3-28 1269/右/单格/13.tiff'
  //ImageFiles[13] := 'D:/project photo/3-28 1269/右/单格/14.tiff'
  //ImageFiles[14] := 'D:/project photo/3-28 1269/右/多格/15.tiff'
  //ImageFiles[15] := 'D:/project photo/3-28 1269/右/多格/16.tiff'
  {
  HTuple end_val28 = (hv_ImageFiles.TupleLength())-1;
  HTuple step_val28 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val28, step_val28); hv_Index += step_val28)
  {
    ReadImage(&ho_Image0, HTuple(hv_ImageFiles[hv_Index]));
    //仿射变换
    //gen_rectangle1 (ROI_0, 219.5, 501.9, 542, 1769.1)
    //reduce_domain (Image0, ROI_0, ImageReduced0)
    //threshold (ImageReduced0, Regions0, 0, 141)
    //opening_rectangle1 (Regions0, RegionOpening0, 3, 3)
    //fill_up (RegionOpening0, RegionFillUp0)
    //orientation_region (RegionFillUp0, Phi0)
    //area_center (RegionFillUp0, Area0, Row0, Column0)
    //vector_angle_to_rigid (Row0, Column0, Phi0, Row0, Column0, 0, HomMat2D0)
    //affine_trans_image (ImageReduced0, Image, HomMat2D0, 'constant', 'false')

    //Image Acquisition 01: Do something
    FindShapeModel(ho_Image0, hv_ModelID, -0.39, 0.78, 0.5, 1, 0.5, "least_squares", 
        0, 0.9, &hv_Row, &hv_Column, &hv_Angle, &hv_Score);
    if (0 != ((hv_Row.TupleLength())==1))
    {
      hv_c += 1;
      dev_display_shape_matching_results(hv_ModelID, "red", hv_Row, hv_Column, hv_Angle, 
          1, 1, 0);
      //gen_cross_contour_xld (Cross, Row, Column, 6, Angle)
      //横坐标-435,+600
      //纵坐标-80，+85
      if (HDevWindowStack::IsOpen())
        SetDraw(HDevWindowStack::GetActive(),"margin");
      //绘制左矩形
      //仿射变换
      GenRectangle1(&ho_Rectanglerotate, hv_Row-60, hv_Column-600, hv_Row+40, hv_Column-400);
      ReduceDomain(ho_Image0, ho_Rectanglerotate, &ho_ImageReducedrotate);
      Threshold(ho_ImageReducedrotate, &ho_Regionrotate, 0, 200);
      EdgesSubPix(ho_ImageReducedrotate, &ho_Edgesrotate, "canny", 5, 20, 60);
      LengthXld(ho_Edgesrotate, &hv_Lengthrotate);
      TupleSort(hv_Lengthrotate, &hv_Sortedrotate);
      SelectContoursXld(ho_Edgesrotate, &ho_SelectedContours, "contour_length", HTuple(hv_Sortedrotate[(hv_Sortedrotate.TupleLength())-1]), 
          HTuple(hv_Sortedrotate[(hv_Sortedrotate.TupleLength())-1]), -0.5, 0.5);
      FitLineContourXld(ho_SelectedContours, "tukey", -1, 0, 5, 2, &hv_RowBegin, 
          &hv_ColBegin, &hv_RowEnd, &hv_ColEnd, &hv_Nr, &hv_Nc, &hv_Dist);
      //获取方向
      LineOrientation(hv_RowBegin, hv_ColBegin, hv_RowEnd, hv_ColEnd, &hv_Phi);
      if (0 != (hv_Phi>=0))
      {
        RotateImage(ho_Image0, &ho_ImageRotate, 90-((hv_Phi*180)/3.141592653), "constant");
      }
      else
      {
        RotateImage(ho_Image0, &ho_ImageRotate, 270-((hv_Phi*180)/3.141592653), "constant");
      }

      //
      //***************开始测量尺寸
      //**外径
      GenRectangle1(&ho_Rectanglediameter1, hv_Row-120, hv_Column-480, hv_Row-80, 
          hv_Column-400);
      ReduceDomain(ho_ImageRotate, ho_Rectanglediameter1, &ho_ImageReduceddiameter1
          );
      Threshold(ho_ImageReduceddiameter1, &ho_Regiondiameter1, 0, 210);
      EdgesSubPix(ho_ImageReduceddiameter1, &ho_Edgesdiameter1, "canny", 2, 20, 40);
      LengthXld(ho_Edgesdiameter1, &hv_Lengthdiameter1);
      TupleSort(hv_Lengthdiameter1, &hv_Sorteddiameter1);
      SelectContoursXld(ho_Edgesdiameter1, &ho_SelectedContoursdiameter1, "contour_length", 
          HTuple(hv_Sorteddiameter1[(hv_Sorteddiameter1.TupleLength())-1]), HTuple(hv_Sorteddiameter1[(hv_Sorteddiameter1.TupleLength())-1]), 
          -0.5, 0.5);
      FitLineContourXld(ho_SelectedContoursdiameter1, "tukey", -1, 0, 5, 2, &hv_RowBegindiameter1, 
          &hv_ColBegindiameter1, &hv_RowEnddiameter1, &hv_ColEnddiameter1, &hv_Nr1, 
          &hv_Nc1, &hv_Dist1);
      //另一条边
      //dev_clear_window ()
      //dev_display (ImageRotate)
      GenRectangle1(&ho_Rectanglediameter2, hv_Row+60, hv_Column-480, hv_Row+100, 
          hv_Column-400);
      ReduceDomain(ho_ImageRotate, ho_Rectanglediameter2, &ho_ImageReduceddiameter2
          );
      Threshold(ho_ImageReduceddiameter2, &ho_Regiondiameter2, 0, 210);
      EdgesSubPix(ho_ImageReduceddiameter2, &ho_Edgesdiameter2, "canny", 2, 20, 40);
      LengthXld(ho_Edgesdiameter2, &hv_Lengthdiameter2);
      TupleSort(hv_Lengthdiameter2, &hv_Sorteddiameter2);
      SelectContoursXld(ho_Edgesdiameter2, &ho_SelectedContoursdiameter2, "contour_length", 
          HTuple(hv_Sorteddiameter2[(hv_Sorteddiameter2.TupleLength())-1]), HTuple(hv_Sorteddiameter2[(hv_Sorteddiameter2.TupleLength())-1]), 
          -0.5, 0.5);
      FitLineContourXld(ho_SelectedContoursdiameter2, "tukey", -1, 0, 5, 2, &hv_RowBegindiameter2, 
          &hv_ColBegindiameter2, &hv_RowEnddiameter2, &hv_ColEnddiameter2, &hv_Nr2, 
          &hv_Nc2, &hv_Dist2);
      //开始计算距离
      AreaCenterXld(ho_SelectedContoursdiameter1, &hv_Areadiameter1, &hv_Rowdiameter1, 
          &hv_Columndiameter1, &hv_PointOrderdiameter1);

      hv_rowavg1 = (hv_RowEnddiameter1+hv_RowBegindiameter1)/2;
      hv_colavg1 = (hv_ColEnddiameter1+hv_ColBegindiameter1)/2;
      hv_rowavg2 = (hv_RowEnddiameter2+hv_RowBegindiameter2)/2;
      hv_colavg2 = (hv_ColEnddiameter2+hv_ColBegindiameter2)/2;
      hv_distance1 = ((hv_rowavg1-hv_rowavg2)*(hv_rowavg1-hv_rowavg2))+((hv_colavg1-hv_colavg2)*(hv_colavg1-hv_colavg2));
      TupleSqrt(hv_distance1, &hv_Sqrtdiameter);
      hv_diameter = hv_diameter.TupleConcat(hv_Sqrtdiameter);



      //gen_rectangle1 (Rectangle, Row-120, Column-650, Row+125, Column+650)

      //测量外径
      //Measure 01: Code generated by Measure 01
      //Measure 01: Prepare measurement     58
      //AmplitudeThreshold1 := 70
      //RoiWidthLen2 := 10
      //set_system ('int_zooming', 'false')
      //Measure 01: Coordinates for line Measure 01 [0]
      //LineRowStart_Measure_01_0 := Row-120
      //LineColumnStart_Measure_01_0 := Column+570
      //LineRowEnd_Measure_01_0 := Row+125
      //LineColumnEnd_Measure_01_0 := Column+570
      //Measure 01: Convert coordinates to rectangle2 type
      //TmpCtrl_Row := 0.5*(LineRowStart_Measure_01_0+LineRowEnd_Measure_01_0)
      //TmpCtrl_Column := 0.5*(LineColumnStart_Measure_01_0+LineColumnEnd_Measure_01_0)
      //TmpCtrl_Dr := LineRowStart_Measure_01_0-LineRowEnd_Measure_01_0
      //TmpCtrl_Dc := LineColumnEnd_Measure_01_0-LineColumnStart_Measure_01_0
      //TmpCtrl_Phi := atan2(TmpCtrl_Dr, TmpCtrl_Dc)
      //TmpCtrl_Len1 := 0.5*sqrt(TmpCtrl_Dr*TmpCtrl_Dr + TmpCtrl_Dc*TmpCtrl_Dc)
      //TmpCtrl_Len2 := RoiWidthLen2
      //gen_rectangle2 (Rectangle2, TmpCtrl_Row, TmpCtrl_Column, TmpCtrl_Phi, TmpCtrl_Len1, RoiWidthLen2)
      //gen_rectangle1 (Rectangle1, TmpCtrl_Row, TmpCtrl_Column, LineRowEnd_Measure_01_0, LineColumnEnd_Measure_01_0)
      //Measure 01: Create measure for line Measure 01 [0]
      //Measure 01: Attention: This assumes all images have the same size!
      //gen_measure_rectangle2 (TmpCtrl_Row, TmpCtrl_Column, TmpCtrl_Phi, TmpCtrl_Len1, TmpCtrl_Len2, 1920, 1200, 'nearest_neighbor', MsrHandle_Measure_01_0)
      //Measure 01: ***************************************************************
      //Measure 01: * The code which follows is to be executed once / measurement *
      //Measure 01: ***************************************************************
      //Measure 01: The image is assumed to be made available in the
      //Measure 01: variable last displayed in the graphics window
      //copy_obj (Image0, Image11, 1, 1)
      //Measure 01: Execute measurements
      //measure_pos (Image11, MsrHandle_Measure_01_0, 12, 58, 'all', 'all', Row_Measure_01_0, Column_Measure_01_0, Amplitude_Measure_01_0, Distance_Measure_01_0)
      //Measure 01: Do something with the results
      //Measure 01: Clear measure when done
      //gen_rectangle1 (Rectangletestdiameter, Row_Measure_01_0[0], Column_Measure_01_0[0], Row_Measure_01_0[1], Column_Measure_01_0[1])
      //close_measure (MsrHandle_Measure_01_0)
      //diameter := [diameter,Distance_Measure_01_0]

      //测量总长
      GenRectangle1(&ho_Rectanglelength1, hv_Row-50, hv_Column-520, hv_Row+50, hv_Column-480);
      ReduceDomain(ho_ImageRotate, ho_Rectanglelength1, &ho_ImageReducedlength1);
      Threshold(ho_ImageReducedlength1, &ho_Regionlength1, 0, 210);
      EdgesSubPix(ho_ImageReducedlength1, &ho_Edgeslength1, "canny", 2, 20, 40);
      LengthXld(ho_Edgeslength1, &hv_Lengthlength1);
      TupleSort(hv_Lengthlength1, &hv_Sortedlength1);
      SelectContoursXld(ho_Edgeslength1, &ho_SelectedContourslength1, "contour_length", 
          HTuple(hv_Sortedlength1[(hv_Sortedlength1.TupleLength())-1]), HTuple(hv_Sortedlength1[(hv_Sortedlength1.TupleLength())-1]), 
          -0.5, 0.5);
      FitLineContourXld(ho_SelectedContourslength1, "tukey", -1, 0, 5, 2, &hv_RowBeginlength1, 
          &hv_ColBeginlength1, &hv_RowEndlength1, &hv_ColEndlength1, &hv_Nrlength1, 
          &hv_Nclength1, &hv_Distlength1);
      //另一条边
      GenRectangle1(&ho_Rectanglelength2, hv_Row-50, hv_Column+520, hv_Row+50, hv_Column+560);
      ReduceDomain(ho_ImageRotate, ho_Rectanglelength2, &ho_ImageReducedlength2);
      Threshold(ho_ImageReducedlength2, &ho_Regionlength2, 0, 210);
      EdgesSubPix(ho_ImageReducedlength2, &ho_Edgeslength2, "canny", 2, 20, 40);
      LengthXld(ho_Edgeslength2, &hv_Lengthlength2);
      TupleSort(hv_Lengthlength2, &hv_Sortedlength2);
      SelectContoursXld(ho_Edgeslength2, &ho_SelectedContourslength2, "contour_length", 
          HTuple(hv_Sortedlength2[(hv_Sortedlength2.TupleLength())-1]), HTuple(hv_Sortedlength2[(hv_Sortedlength2.TupleLength())-1]), 
          -0.5, 0.5);
      FitLineContourXld(ho_SelectedContourslength2, "tukey", -1, 0, 5, 2, &hv_RowBeginlength2, 
          &hv_ColBeginlength2, &hv_RowEndlength2, &hv_ColEndlength2, &hv_Nrlength2, 
          &hv_Nclength2, &hv_Distlength2);

      DistanceSs(hv_RowBeginlength1, hv_ColBeginlength1, hv_RowEndlength1, hv_ColEndlength1, 
          hv_RowBeginlength2, hv_ColBeginlength2, hv_RowEndlength2, hv_ColEndlength2, 
          &hv_DistancelengthMin, &hv_DistancelengthMax);
      //rowavg3 := (RowEndlength1+RowBeginlength1)/2
      //colavg3 := (ColEndlength1+ColBeginlength1)/2
      //rowavg4 := (RowEndlength2+RowBeginlength2)/2
      //colavg4 := (ColEndlength2+ColBeginlength2)/2
      //distance2 := (rowavg3-rowavg4)*(rowavg3-rowavg4)+(colavg3-colavg4)*(colavg3-colavg4)
      //tuple_sqrt (distance2, Sqrtlength)
      hv_lengthmin = hv_lengthmin.TupleConcat(hv_DistancelengthMin);
      hv_lengthmax = hv_lengthmax.TupleConcat(hv_DistancelengthMax);

      //Measure 02: Code generated by Measure 02
      //Measure 02: Prepare measurement
      //AmplitudeThreshold2 := 90
      //RoiWidthLen2 := 10
      //set_system ('int_zooming', 'true')
      //Measure 02: Coordinates for line Measure 02 [0]
      //367
      //LineRowStart_Measure_02_0 := Row+2.5
      //LineColumnStart_Measure_02_0 := Column-600
      //LineRowEnd_Measure_02_0 := Row+2.5
      //LineColumnEnd_Measure_02_0 := Column+650
      //Measure 02: Convert coordinates to rectangle2 type
      //TmpCtrl_Row := 0.5*(LineRowStart_Measure_02_0+LineRowEnd_Measure_02_0)
      //TmpCtrl_Column := 0.5*(LineColumnStart_Measure_02_0+LineColumnEnd_Measure_02_0)
      //TmpCtrl_Dr := LineRowStart_Measure_02_0-LineRowEnd_Measure_02_0
      //TmpCtrl_Dc := LineColumnEnd_Measure_02_0-LineColumnStart_Measure_02_0
      //TmpCtrl_Phi := atan2(TmpCtrl_Dr, TmpCtrl_Dc)
      //TmpCtrl_Len1 := 0.5*sqrt(TmpCtrl_Dr*TmpCtrl_Dr + TmpCtrl_Dc*TmpCtrl_Dc)
      //TmpCtrl_Len2 := RoiWidthLen2
      //Measure 02: Create measure for line Measure 02 [0]
      //Measure 02: Attention: This assumes all images have the same size!
      //gen_rectangle2 (Rectangle3, TmpCtrl_Row, TmpCtrl_Column, TmpCtrl_Phi, TmpCtrl_Len1, TmpCtrl_Len2)
      //gen_measure_rectangle2 (TmpCtrl_Row, TmpCtrl_Column, TmpCtrl_Phi, TmpCtrl_Len1, TmpCtrl_Len2, 1920, 1200, 'nearest_neighbor', MsrHandle_Measure_02_0)
      //Measure 02: ***************************************************************
      //Measure 02: * The code which follows is to be executed once / measurement *
      //Measure 02: ***************************************************************
      //Measure 02: The image is assumed to be made available in the
      //Measure 02: variable last displayed in the graphics window
      //copy_obj (ImageRotate, Image12, 1, 1)
      //Measure 02: Execute measurements
      //measure_pos (Image12, MsrHandle_Measure_02_0, 1, 70, 'all', 'all', Row_Measure_02_0, Column_Measure_02_0, Amplitude_Measure_02_0, Distance_Measure_02_0)
      //gen_rectangle1 (Rectanglelength, Row_Measure_02_0[0], Column_Measure_02_0[0], Row_Measure_02_0[1], Column_Measure_02_0[1])
      //Measure 02: Do something with the results
      //Measure 02: Clear measure when done
      //close_measure (MsrHandle_Measure_02_0)
      //length := [length,Distance_Measure_02_0]

    }
  }
  }
  ClearShapeModel(hv_ModelID);
}


#ifndef NO_EXPORT_APP_MAIN

#ifdef __APPLE__
// On OS X systems, we must have a CFRunLoop running on the main thread in
// order for the HALCON graphics operators to work correctly, and run the
// action function in a separate thread. A CFRunLoopTimer is used to make sure
// the action function is not called before the CFRunLoop is running.
HTuple      gStartMutex;
H_pthread_t gActionThread;

static void timer_callback(CFRunLoopTimerRef timer, void *info)
{
  UnlockMutex(gStartMutex);
}

static Herror apple_action(void **parameters)
{
  LockMutex(gStartMutex);
  action();
  CFRunLoopStop(CFRunLoopGetMain());
  return H_MSG_OK;
}

static int apple_main(int argc, char *argv[])
{
  Herror                error;
  CFRunLoopTimerRef     Timer;
  CFRunLoopTimerContext TimerContext = { 0, 0, 0, 0, 0 };

  CreateMutex("type","sleep",&gStartMutex);
  LockMutex(gStartMutex);

  error = HpThreadHandleAlloc(&gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleAlloc failed: %d\n", error);
    exit(1);
  }

  error = HpThreadCreate(gActionThread,0,apple_action);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadCreate failed: %d\n", error);
    exit(1);
  }

  Timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
                               CFAbsoluteTimeGetCurrent(),0,0,0,
                               timer_callback,&TimerContext);
  if (!Timer)
  {
    fprintf(stderr,"CFRunLoopTimerCreate failed\n");
    exit(1);
  }
  CFRunLoopAddTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRunLoopRun();
  CFRunLoopRemoveTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRelease(Timer);

  error = HpThreadHandleFree(gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleFree failed: %d\n", error);
    exit(1);
  }

  ClearMutex(gStartMutex);
  return 0;
}
#endif

int main(int argc, char *argv[])
{
  // Default settings used in HDevelop (can be omitted) 
  int ret=0;
  SetSystem("width", 512);
  SetSystem("height", 512);

#if defined(_WIN32)
  SetSystem("use_window_thread", "true");
#elif defined(__linux__)
  XInitThreads();
#endif

#ifndef __APPLE__
  action();
#else
  ret = apple_main(argc,argv);
#endif
  return ret;
}

#endif


#endif


